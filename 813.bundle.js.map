{"version":3,"file":"813.bundle.js","mappings":"mJAAA,oD,6MCeA,MAAMA,GAAa,QAAO,MAIpBC,EAAc,CAClBC,QAAS,IAAG;;;;;;;;;;;;;;;;;;;KA4BDC,EAAS,KACpB,MAAM,MAAEC,IAAU,UACZC,GAAU,IAAAC,UAAQ,KACtB,QAAWC,MAAMC,QAAQJ,GAASA,EAAM,GAAKA,IAC5C,CAACA,KACGK,IAAU,UACXC,EAAaD,EAAOE,IAAI,gBAAkB,GAC1CC,EAASH,EAAOE,IAAI,WAAa,GAChCE,EAAYC,IACjB,IAAAC,UAA2B,IAGvBC,EAAQX,EAAUY,OAAOZ,GAASa,SAAS,IAAM,KACjDC,GAAQ,IAAAb,UAAQ,IACpBL,EAAY,OACX,KAGDmB,GACA,QACEC,EACAC,OAASC,QAASC,GAAe,CAAED,QAAS,MAAM,KAClDE,KAGF,OAAaN,GAAS,IAAG,uBAE3B,IAAAO,YAAU,KACLP,GACDC,EAAO,CAAEO,UAAW,CAClBtB,QAASW,EACTY,gBAAiB,wBACjBlB,e,GAGH,CAACM,EAAON,EAAYS,EAAOC,IAE9B,MAAOS,EAAOC,IAAY,IAAAf,UAAS,mBAC7B,YAAEgB,EAAW,WAAEC,IAAe,WAC7BV,EAAOW,IAAY,IAAAlB,UACd,MAATI,EAGG,0FAAI,QAAW,iBACd,GAmDP,OAhDA,IAAAO,YACE,IAAMP,GAASc,EAAST,IACxB,CAACL,EAAOK,KAGV,IAAAE,YAAU,KACOQ,WACb,GAAG7B,EAAS,CACV,MAAM8B,QAAYH,GAAYG,IAAI9B,IAClC,IAAI8B,EAAK,OACT,MAAMC,QAAiBC,OAAM,QAAQF,IAC/BV,QAAaW,EAASE,OAC5BR,EAASL,EAAKc,K,GAGlBC,EAAQ,GACP,CAACnC,EAAS2B,KAEb,IAAAN,YAAU,KACQQ,WACd,GAAGT,EAAM,CACP,GAAGA,EAAKgB,KAAKC,OAAS,EACpB,MAAM,IAAIC,MAAM,OAAOlB,EAAKgB,KAAKC,eAEV,IAArBjB,EAAKgB,KAAKC,QACZ5B,QACQ8B,QAAQC,IACZpB,EAAKgB,KAAK,GAAGK,UAAUC,KACrBb,MAAOc,IACL,IAAI,MAAEC,GAAUD,EAChB,MAAME,QACEnB,GAAaoB,cAAcF,IAEhCC,IACDD,EAAQC,GAEV,MAAM,SAAEE,EAAQ,GAAEC,GAAOL,EACzB,MAAO,CAAEC,QAAOG,WAAUC,KAAI,K,GAQ5CC,EAAS,GACR,CAAC7B,EAAMM,IAEPV,EAAgB,4CAGjB,gBAAC,KAAG,CAACkC,GAAI,GACP,gBAAC,KAAQ,MACT,gBAAC,KAAO,CAACC,GAAI,GAAIC,SAAU,IACxB5B,GAEFP,GACC,gBAAC,KAAK,CAACoC,OAAO,SACZ,gBAAC,KAAS,MACV,gBAAC,KAAU,gBACX,gBAAC,IAAgB,KAAEpC,IAGA,IAAtBT,EAAW6B,OACV,gBAAC,KAAK,CAACgB,OAAO,WACZ,gBAAC,KAAS,MACV,gBAAC,KAAU,gBACX,gBAAC,IAAgB,K,8BACatD,E,MAIhC,gBAAC,KAAW,CAACuD,MAAOC,OAAOhD,GAAU,GAClCC,EAAWkC,KAAI,EAAGE,QAAOG,YAAYS,IACpC,gBAAC,KAAQ,CAACC,IAAKD,EAAKN,GAAI,GACrB,GAAGN,MAAUG,SAzJd,MA8JPvC,EAAW6B,QACV,gBAAC1C,EAAU,CACT+D,GAAI,CACFC,SAAU,WAAW,IAAIC,gBAAgB,CACvC7D,QACA8D,YAAarD,EAAWsD,OAAO,GAAG,GAAGd,GACrCzC,QAASgD,OAAOhD,GApKhB,KAoKiCM,iBAEpC,QAMR,EAGH,G","sources":["webpack://@chievemints/ui/./src/contracts/polygon/BulkDisbursableNFTs.address.ts","webpack://@chievemints/ui/./src/pages/owners.tsx"],"sourcesContent":["export default '0x85fCaAFc0dA050FCE685DcB8965F0C1Aa1Ba466b'","import { gql, useLazyQuery } from '@apollo/client'\nimport {\n  chakra, Box, Heading, ListItem, OrderedList, Text,\n  Alert, AlertIcon, AlertTitle, AlertDescription,\n} from '@chakra-ui/react'\nimport React, { useEffect, useMemo, useState } from 'react'\nimport contractAddress from '../contracts/polygon/BulkDisbursableNFTs.address'\nimport {\n  useParams, useSearchParams, Link as ReactRouterLink,\n} from 'react-router-dom'\nimport { httpURL, deregexify, capitalize } from '@/lib/helpers'\nimport { HomeLink } from '@/components'\nimport { useWeb3 } from '@/lib/hooks'\nimport { contractNetwork } from '@/config'\n\nconst RouterLink = chakra(ReactRouterLink)\n\nconst LIMIT = 100 // The Graph's return limit\n\nconst ownersQuery = {\n  polygon: gql`\n    query NFTOwners(\n      $tokenId: String\n      $contractAddress: String\n      $startAfter: String\n    ) {\n      nfts(where:{ \n        contract: $contractAddress,\n        tokenID: $tokenId\n      }) {\n        ownership(where: {\n          id_gt: $startAfter\n        }) {\n          id\n          owner\n          quantity\n        }\n      }\n    }\n  `,\n}\n\nexport type Ownership = {\n  id: string\n  owner: string\n  quantity: number\n}\n\nexport const Owners = () => {\n  const { nftId } = useParams() \n  const tokenId = useMemo(() => (\n    deregexify(Array.isArray(nftId) ? nftId[0] : nftId)\n  ), [nftId])\n  const [params] = useSearchParams()\n  const startAfter = params.get('start_after') ?? ''\n  const offset = params.get('offset') ?? 0\n  const [ownerships, setOwnerships] = (\n    useState<Array<Ownership>>([])\n  )\n\n  const decId = tokenId ? BigInt(tokenId).toString(10) : null\n  const query = useMemo(() => (\n    ownersQuery[contractNetwork as keyof typeof ownersQuery]\n  ), [])\n\n  const [\n    search,\n    {\n      loading,\n      error: { message: queryError } = { message: null },\n      data\n    }\n  ] = (\n    useLazyQuery(query ?? gql`query Empty { id }`)\n  )\n  useEffect(() => {\n    if(query) {\n      search({ variables: {\n        tokenId: decId,\n        contractAddress: contractAddress.toLowerCase(),\n        startAfter,\n      } })\n    }\n  }, [decId, startAfter, query, search])\n\n  const [title, setTitle] = useState('𝘜𝘯𝘬𝘯𝘰𝘸𝘯')\n  const { ensProvider, roContract } = useWeb3()\n  const [error, setError] = useState(\n    (query == null ? (\n      'Retrieving owners requires access to a subgraph'\n      + ' & one hasn’t been configured for the '\n      + ` ${capitalize(contractNetwork)} network.`\n     ) : ( queryError ))\n  )\n\n  useEffect(\n    () => query && setError(queryError),\n    [query, queryError],\n  )\n\n  useEffect(() => {\n    const lookup = async () => {\n      if(tokenId) {\n        const uri = await roContract?.uri(tokenId)\n        if(!uri) return\n        const response = await fetch(httpURL(uri)!)\n        const data = await response.json()\n        setTitle(data.name)\n      }\n    }\n    lookup()\n  }, [tokenId, roContract])\n\n  useEffect(() => {\n    const process = async () => {\n      if(data) {\n        if(data.nfts.length > 1 ) {\n          throw new Error(`Got ${data.nfts.length} NFTs`)\n        }\n        if (data.nfts.length === 1) {\n          setOwnerships(\n            await Promise.all(\n              data.nfts[0].ownership.map(\n                async (oship: Ownership) => {\n                  let { owner } = oship\n                  const ens = (\n                    await ensProvider?.lookupAddress(owner)\n                  )\n                  if(ens) {\n                    owner = ens \n                  }\n                  const { quantity, id } = oship\n                  return { owner, quantity, id }\n                }  \n              )\n            )\n          )\n        }\n      }\n    }\n    process()\n  }, [data, ensProvider])\n\n  if(loading) return <>Loading…</>\n\n  return (\n    <Box ml={8}>\n      <HomeLink/>\n      <Heading mt={10} fontSize={20}>\n        {title}\n      </Heading>\n      {error && (\n        <Alert status=\"error\">\n          <AlertIcon/>\n          <AlertTitle>¡Error!</AlertTitle>\n          <AlertDescription>{error}</AlertDescription>\n        </Alert>\n      )}\n      {ownerships.length === 0 ? (\n        <Alert status=\"warning\">\n          <AlertIcon/>\n          <AlertTitle>¡Empty!</AlertTitle>\n          <AlertDescription>\n            No owners found for token #{nftId}.\n          </AlertDescription>\n        </Alert>\n      ) : (\n        <OrderedList start={Number(offset) + 1}>\n          {ownerships.map(({ owner, quantity }, idx) => (\n            <ListItem key={idx} ml={6}>\n              {`${owner} (${quantity})`}\n            </ListItem>\n          ))}\n        </OrderedList>\n      )}\n      {ownerships.length === LIMIT && (\n        <RouterLink\n          to={{\n            pathname: `/owners?${new URLSearchParams({\n              nftId,\n              start_after: ownerships.slice(-1)[0].id,\n              offset: (Number(offset) + LIMIT).toString(),\n            })}`\n          }}\n        >\n          Next\n        </RouterLink>\n      )}\n    </Box>\n  )\n}\n\nexport default Owners"],"names":["RouterLink","ownersQuery","polygon","Owners","nftId","tokenId","useMemo","Array","isArray","params","startAfter","get","offset","ownerships","setOwnerships","useState","decId","BigInt","toString","query","search","loading","error","message","queryError","data","useEffect","variables","contractAddress","title","setTitle","ensProvider","roContract","setError","async","uri","response","fetch","json","name","lookup","nfts","length","Error","Promise","all","ownership","map","oship","owner","ens","lookupAddress","quantity","id","process","ml","mt","fontSize","status","start","Number","idx","key","to","pathname","URLSearchParams","start_after","slice"],"sourceRoot":""}